---
title: javascript 是如何存储数字的
date: 2022/06/22 18:06:30
tags: [前端]
mathjax: true
---

## 存储标准

计算机是二进制的。浮点数没有办法是用二进制进行精确表示。我们的 CPU 表示浮点数由两个部分组成：**指数**和**尾数**，这样的表示方法一般都会失去一定的精确度，有些浮点数运算也会产生一定的误差，是实数的无限精度跟计算机的有限内存之间的矛盾，通用语言中的浮点数都是按照**二进位浮点数算术标准**(IEEE 754)标准存储。

一般语言把数字区分整数型和小数型以不同标准存储，但是` js` 比较特殊，在` js `中，不管是整数还是小数都是以 IEEE 754 标准中的**双精度浮点法**(Double 64)存储的。整数 `1 `被当成` 1.0 `存储。

## 双精度浮点法

先来介绍一下双精度浮点法，比起[单精度浮点法](https://zh.wikipedia.org/wiki/%E5%96%AE%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8)，双精度浮点法使用 `64 位`二进制来储存一个浮点数。它可以表示二进位制的 53 位有效数字，其可以表示的数字的范围为

$$
[-(2^{53}),  2^{53} - 1]
$$

#### 结构

包含 64 位二进制位，分别是**符号位**，**指数位**，**尾数位**。

sign bit（符号）：占位 1 比特，用来表示数值正负，0 代表数值为正，1 代表数值为负。

exponent（指数）：占位 11 比特，用来表示次方数，占位越多，可以表示数字的范围越大。

mantissa（尾数）：占位 52 比特，用来表示精确度，可以理解成占位越多，那么保存小数点后更多的位数。

![General double precision float.png](https://upload.wikimedia.org/wikipedia/commons/7/76/General_double_precision_float.png)

## 二进制转换

首先要把数字转换为二进制存储，这里区分两种情况，整数和小数(整数部分和小数部分)

- 整数：整数除以 `2`，记录结果和余数。然后用上次结果继续除以 `2`，再次记录商和余数。重复这个步骤，直到商为 `0 `为止。那么所得余数从后往前排列就是这个整数的二进制。

- 小数：小数位乘以 `2`，记录结果，区分整数位和小数位，然后继续用小数位乘以` 2`，再次记录结果。重复这个步骤，直到小数位为 `0` 为止，那么其中得到的整数结果从前往后排列就是小数的二进制

#### 整数 8 转换二进制过程

```javascript
8 / 2 = 4 // 余数 0
4 / 2 = 2 // 余数 0
2 / 2 = 1 // 余数 0
1 / 2 = 0 // 余数 1
```

然后把倒过来把余数排列，`1000`就是 8 的二进制结果

#### 小数 0.25 转换二进制过程

```javascript
0.25 * 2 = 0.5 // 整数位：0 小数位：0.5
0.5 * 2 = 1 // 整数位：1 小数位：0
```

整数位结果从前往后取出得到`01`就是 0.25 的二进制结果

#### 整数+小数 8.25 的二进制过程

实际拆解成整数位 8 和小数 0.25，分别按照对应的方法去转换，8 的二进制就是` 1000`，0.25 的二进制是 `01`，加个小数点合并到一起就是 1000.01，所以 8.25 的二进制位 `1000.01`。

## 理解 10 进制以双精度浮点法存储到内存

按照上述步骤，8.25 转换二进制得到 1000.01，那么 1000.01 是如何以双精度浮点法存储的呢，第一步先把 1000.01 用二进制科学记数法表示，得到 1.00001 \* 2^3，然后我们把它拆分下，分别存入符号位，指数位，尾数位，

- 符号位存入` 0`，因为` 1000.01` 是正数
- 指数位存入 1026 的二进制` 10000000010`，这里需要解释下，指数应该是 3，为什么存入` 1026`。是因为指数位有 `11` 位，可以表示` 0 ~ 2^11`，也就是` 0 ~ 2048`， 因为指数可能是正或者负的，这时计算机不仅仅要识别指数有多大，还要识别是正是否，无疑增加了复杂度，为了简化这个问题，使用了偏移量的概念，`0 ~ 2048` 没办法表示负数，就把 0 ~ 2048 从中一刀劈开，范围变成-1024 到+1024， 包括 0 的话，就是`-1024` 到 `+1023` 这个时候，存储的时候让原本的指数`+1024 `的偏移量，可以保证，存储的都是整数，当二进制转回十进制的时候，再减去 1024 就可以了，那 1024 + 3 应该是 1027 啊，为什么实际用了 1026 呢，因为人们为了特殊用处，不允许使用` 0 `和 `1023 `这两个数字表示指数，少了 2 个数字，自然就只好采用` 1023 `了。所以指数` 3 + 1023` 为` 1026`
- ​ 尾数位存入` 00001`，把 1.0001 小数点前的 1 省略，因为转换为二进制位后，只可能是 0 和 1，再进行二进制科学记数法，第一位一定大于 0，所以又排除了 0，所以小数点前的数只能是 1，就可以省略掉

所以使用双精度浮点法 8.25 存储的结果为：
![8.25 double 64 expamle](./javascript是如何存储数字的/f57192d6-0ec2-4ae9-af18-5c8393ad2ee1.png)

## 转回十进制

先看转换公式：

$$
(-1)^{sign} \times 2^{exponent}  \times  (1 + mantissa)
$$

还是用` 8.25` 举例，符号位为 0，指数位为 1026 - 1023 (偏移量) = 3，尾数为 00001，可得：
$$
(-1)^{0} \times 2^{3}  \times  (1 + 0.00001) = 1   \times  1000.01
$$
把二进制结果`1000.01`转换为十进制，先把小数位按照第 1 位的值\*2^(-1)，第 2 位的值\*2^(-2)，第3位的值\*2^(-3) 只要是二进制位不是1都要加到一起，然后把最后结果相加得0.25：
$$
0 \times 2^{-1} + 1 \times 2^{-2}   = 0.25
$$

整数位1000转十进制，和小数位计算方式一样，只是指数从负数换成整数就好了，最终结果是8，把小数位和整数位结果加到一起就是最终结果了8.25了

$$
0 \times 2^{1} + 0 \times 2^{2} + 0 \times 2^{3} + 1 \times 2^{4}  = 8
$$
